---
title: "Data Science Dashboard"
output: 
  flexdashboard::flex_dashboard:
    vertical_layout: fill
    # vertical_layout: fill
runtime: shiny
---

```{r setup, include=FALSE}
library(dplyr)
library(flexdashboard)
library(igraph)
library(readxl)
library(sf)
library(sfnetworks)
library(tidygraph)
library(tidyverse)
library(tmap)
library(geosphere)

tmap_mode("view")
```

Trains in London {data-orientation=rows}
=====================================
```{r, include=FALSE}
Stations <- st_read("data/tfl_stations_new.json")
Lines <- st_read("data/tfl_lines_new.json")
Zones <- st_read("data/tfl_zones.json") %>%
  rename("Name" = "name")

colors <- c(
  "#B26300", # Bakerloo
  "#DC241F", # Central
  "#FFD329", # Circle
  "#9364CC", # Crossrail
  "#e1eb5b", # Crossrail 2
  "#007D32", # District
  "#00AFAD", # DLR
  "#E0A9BE", # Hammersmith & City
  "#A1A5A7", # Jubliee
  "#9B0058", # Metropolitan
  "#000000", # Northern
  "#EF7B10", # Overground
  "#0019A8", # Piccadilly
  "#0098D8", # Victoria
  "#93CEBA" # Waterloo & City
)

tube_lines <- c("Bakerloo", "Central", "Circle", "District", "Hammersmith", "Jubilee", "Metropolitan", "Northern", "Piccadilly", "Victoria", "Waterloo")

num_station <- nrow(Stations)

rail_len <- st_length(Lines) %>%
  sum()
```
Row
-------------------------------------

### Total number of train stations by 2030s

```{r}
valueBox(num_station, icon = "fa-subway")
```

### Total track length

```{r}
valueBox(sprintf("%d km", round(rail_len / 1000)))
```

Row
-------------------------------------

### Tube System Map including Overground, DLR and Crossrail
```{r}
Stations2 <-  Stations %>%
  rename("Number of Lines" = "Number.of.Lines", "Station ID" = "Station.ID", "Line(s)" = "Lines")
tm_shape(Zones)+
  tm_polygons(col="Name", alpha=.2, legend.show=FALSE)+
  tm_shape(Lines) +
  tm_lines(col="Line", scale=3, palette = colors) +
  tm_shape(Stations2) +
  tm_dots(scale=1.5)
```

National Rail
===============

```{r, include=FALSE}
nr_stations <- st_read("data/nr_stations.json")
nr_lines <- st_read("data/nr_lines.json")
```

```{r}
tm_shape(nr_lines) +
  tm_lines() +
  tm_shape(nr_stations) +
  tm_dots()
```

Underpasses
================

```{r, include=FALSE}
# Import London map of boroughs
boroughs <- st_read("data/gis/London_Borough_Excluding_MHW.shp")
boroughs <- select(boroughs, NAME, GSS_CODE, HECTARES, NONLD_AREA, geometry)

height_restrictions <- read_excel("data/london_height-restrictions.xlsx")
# Extract simplified underpass data before conversion
underpasses_road_number <- select(height_restrictions, `Road number`)
# Extract categories from text and convert to double:
height_restrictions <- mutate(height_restrictions, `height_temp` = str_replace_all(`Height restriction (m)`, c("Between " = "", "Up to 3.0" = "0")))
height_restrictions <- mutate(height_restrictions, height = as.double(str_sub(`height_temp`, 1, 3)))
height_restrictions <- st_as_sf(height_restrictions, coords = c("Lng", "Lat"), crs = 4326) 

# Read data from OSM CSV export
osm_underpasses <- read.csv2("data/london_underpasses.csv", encoding = "UTF-8", sep = "\t", na.strings = c(""))
# data without a maximum clearance is not useful and mostly due to complex geometries
osm_underpasses <- filter(osm_underpasses, !is.na(maxheight))
osm_underpasses <- st_as_sf(osm_underpasses, coords = c("X.lon", "X.lat"), crs = 4236)
osm_underpasses <- st_transform(osm_underpasses, crs = 3875)

# Convert text strings to numbers
# Extension: convert imperial measurements to metres
osm_underpasses <- mutate(osm_underpasses, height = as.numeric(maxheight))
```

Column {data-width=350}
-----------------------------------------------------------------------

### Underpasses based on National Statistics and Ordnance Survey

```{r}
tm_shape(boroughs) + tm_polygons() + tm_shape(height_restrictions) + tm_dots(col = "height")
```

> Contains National Statistics data © Crown copyright and database right [2015]
> Contains Ordnance Survey data © Crown copyright and database right [2015]

### Underpasses by borough (OS)

```{r}
ggplot(height_restrictions, mapping=aes(x = `Borough`, fill=factor(height))) + geom_bar() +
  theme(axis.text.x = element_text(angle = -45, hjust = 0.0, vjust = 0.2)) +
  scale_y_continuous("Number of underpasses") +
  guides(fill = guide_legend(title = "minimum\nclearance"))
# X axis text orientation: https://ggplot2-book.org/polishing.html#theme-axis
```

Column {data-width=350}
-----------------------------------------------------------------------

### Underpasses based on OpenStreetMap

```{r}
tm_shape(boroughs) + tm_polygons() + tm_shape(osm_underpasses) + tm_dots(col = "height")
```

> © [OpenStreetMap](https://osm.org/copyright) contributors

### Underpasses by road number (OS)

```{r}
# Data queried via https://overpass-api.de/query_form.html
# [out:csv("name","highway","maxheight",::lat,::lon)]
# [timeout:180]
# ;
# (
#   way
#     ["maxheight"]
#     ["highway"]
#     (area:3600175342);
# );
# out center;
# >;
# out;
underpasses_road_number <- filter(underpasses_road_number, !is.na(`Road number`))
underpasses_road_number <- group_by(underpasses_road_number, `Road number`)
underpasses_road_number <- summarise(underpasses_road_number, number = n())
underpasses_road_number <- arrange(underpasses_road_number, desc(number))
knitr::kable(underpasses_road_number)
```

Accidents
==========
```{r, include = FALSE}
accidents <- read.csv2("data/london_2019-road-accidents.csv", encoding = "UTF-8", sep = ",")
```

Data source <https://roads.data.tfl.gov.uk/AccidentStats/Dev/2019-gla-data-extract-vehicle.csv>

Column {data-width=350}
-------------------------------------------------------------------------------------------

### Accidents per borough
```{r}
boroughaccidents <- group_by(accidents, Borough)
boroughaccidents <- summarise(boroughaccidents, number = n())
boroughaccidents <- mutate(boroughaccidents, Borough = str_replace(Borough, "-UPON-THAMES", " UPON THAMES"))
boroughaccidents <- mutate(boroughaccidents, Borough = str_replace(Borough, " & ", " AND "))
boroughaccidents <- rename(boroughaccidents, BName = Borough)
ba_spatial <- left_join(mutate(boroughs, BName = str_to_upper(NAME)), boroughaccidents)
ba_spatial <- select(ba_spatial, NAME, GSS_CODE, HECTARES, NONLD_AREA, number, geometry)
ba_spatial <- rename(ba_spatial, Accidents = number)

# Coloring doc: https://geocompr.github.io/post/2019/tmap-color-scales/#pretty
tm_shape(ba_spatial) + tm_polygons(col = "Accidents") + tm_legend(legend.outside = TRUE)
```

### Percentage of female drivers in accidents
```{r, size=200}
driver_sex <- group_by(accidents, Driver.Sex)
driver_sex <- summarise(driver_sex, n = n())
female_drivers <- filter(driver_sex, Driver.Sex == "2 FEMALE")[2]
male_drivers <- filter(driver_sex, Driver.Sex == "1 MALE")[2]
unidentified_drivers <- filter(driver_sex, Driver.Sex == "3 NOT TRACED")[2]
valueBox(round(female_drivers / (female_drivers + male_drivers + unidentified_drivers) * 100, digits = 0), icon = "fa-female")
```

### Median driver age
```{r}
driver_age <- summarise(filter(accidents, Driver.Age != 0), age = median(Driver.Age))
valueBox(driver_age)
```


Column {data-width=350}
-------------------------------------------------------------------------------------------

### Vehicle manoeuvres
```{r}
manoeuvres <- transmute(accidents, manoeuvre = str_sub(Vehicle.Manoeuvres, 4), skid = str_sub(Vehicle.Skidding, 3))
manoeuvres <- group_by(manoeuvres, manoeuvre, skid)
manoeuvres <- summarise(manoeuvres, number = n())
knitr::kable(manoeuvres)
```


Bus Line App
===================================== 

Column {.sidebar} 
-----------------------------------------------------------------------

```{r}
data_day <- read.csv("data/all_bus_lines.csv") %>%
  mutate(switch = "day") %>%
  select(-X.1, -X)
  
data_night <- read.csv("data/all_bus_lines_night.csv") %>%
  mutate(switch = "night") %>%
  select(-X)

data <- rbind(data_day, data_night)

choices <- as.character(data$lineId)

selectInput("lineId", 
            "Select Line: ", 
            unique(choices),
            selected = "1",
            multiple = FALSE)

```
Row 
-----------------------------------------------------------------------

### From
```{r}
renderValueBox({

start_point <- data %>%
  filter(lineId == input$lineId) %>%
  select(name)

valueBox(start_point$name[1], 
         icon = "fa-arrow-circle-down")
})

```
### To
```{r}
renderValueBox({
  
end_point <- data %>%
  filter(lineId == input$lineId)
  index <- end_point %>%
  nrow()
  
valueBox(end_point$name[index], 
         icon = "fa-arrow-circle-up")
  
})

```
### Number of stops
```{r}
renderValueBox({
 
number_stops <- data %>%
  filter(lineId == input$lineId) %>%
  nrow()
  
valueBox(number_stops,
          icon = "fa-bus-alt")    
})

```

### Distance
```{r}
renderValueBox({
 
distance <- data %>%
  filter(lineId == input$lineId) %>%
  st_as_sf(coords = c("Location_Easting", "Location_Northing"), crs = 27700) %>%
  group_by(lineId) %>%
  summarise(do_union = FALSE) %>%
  st_cast("LINESTRING") %>%
  st_length()

distance <- (distance/1000) %>%
  round(digits = 2)
  
valueBox(paste(distance, "km"),
          icon = "fa-road")
})

```

### Time
```{r}
renderValueBox({
 
data_dist <- data %>%
  filter(lineId == input$lineId)

distance <- data_dist %>%
  st_as_sf(coords = c("Location_Easting", "Location_Northing"), crs = 27700) %>%
  group_by(lineId) %>%
  summarise(do_union = FALSE) %>%
  st_cast("LINESTRING") %>%
  st_length()

avg_speed <- (data_dist$Average_Speed[1] / 1.609)

time <- (((as.numeric(distance)/1000)*60)/(avg_speed)) %>%
  round(digits = 0)
  
valueBox(paste(time, "min"),
          icon = "fa-clock")
})

```
Column {data-width=650}
-----------------------------------------------------------------------

### Route

```{r}
bus_line <- reactive({
  data %>%
    filter(lineId == input$lineId) %>%
    st_as_sf(coords = c("Location_Easting", "Location_Northing"), crs = 27700)
 })

tmap_mode("view")

renderTmap({
  
net <- bus_line() %>%  
  group_by(lineId) %>%
  summarise(do_union = FALSE) %>%
  st_cast("LINESTRING") %>%
  as_sfnetwork(directed = TRUE)  
  
tm_shape(st_as_sf(net, "edges")) + 
  tm_lines(id = c("Line" = "lineId"),
           scale = 2) +
  tm_shape(bus_line()) + 
  tm_dots(col = "#dc241f",
          size = 0.04, 
          id = "name") + 
    tm_shape(st_as_sf(net, "nodes")) + 
    tm_dots(col = "#0019a8", 
            size = 0.1,
            id = "name")
})

```
Network Analysis - Nightbuses
===================================== 

Column {data-width=650}
-----------------------------------------------------------------------

### Betweenness centrality

```{r}

# Simplified night bus network

bus_lines_mp <- read.csv("data/all_bus_lines_night.csv") %>%
  filter(!is.na(Location_Easting)) %>%
  group_by(parentId) %>%
  mutate(Location_Easting = mean(Location_Easting)) %>%
  mutate(Location_Northing = mean(Location_Northing))

# Simplified bus stops
stop_mp <- bus_lines_mp %>%
  select(parentId, stationId, name, Location_Easting, Location_Northing) %>%
  unique()

# Create edges and nodes for sfnetworks

nodes <- bus_lines_mp %>%
  select(X, lineId,parentId, Location_Easting, Location_Northing, name) %>%
  rename("nodeID" = X) %>%
  mutate(start = "start", end = "end") %>%
  gather(start_end, end, start:end)
  
nodes_start <- nodes %>%
  filter(start_end == "start") %>%
  group_by(lineId) %>% 
  mutate(Index_Group = row_number()) %>%
  filter(Index_Group != max(n())) %>%
  ungroup()

nodes_end <- nodes %>%
  filter(start_end == "end") %>%
  group_by(lineId) %>% 
  mutate(Index_Group = row_number()) %>%
  filter(Index_Group != 1) %>%
  ungroup() %>%
  mutate(nodeID = nodeID + 10000)  
    
edges <- cbind(D1 = nodes_start, D2 = nodes_end) %>%
  rename(c(D1.lineId, D1.Location_Easting, D1.Location_Northing, D2.Location_Easting, D2.Location_Northing),
         "lineId" = D1.lineId,
         "lat_start" = D1.Location_Easting, 
         "lon_start" = D1.Location_Northing, 
         "lat_end" = D2.Location_Easting, 
         "lon_end" = D2.Location_Northing) %>%
  select(lineId, D1.name, lat_start, lon_start, lat_end, lon_end) %>%
  unite(start_point, lat_start:lon_start, sep = "__") %>%
  unite(end_point, lat_end:lon_end, sep = "__") %>%
  mutate(Index = row_number()) %>% 
  gather(D1.name, point, start_point:end_point) %>%
  arrange(Index) %>%
  separate(point, c("lat", "lon"), sep = "__") %>%
  st_as_sf(coords = c("lat", "lon"), crs = 27700) %>%
  group_by(Index) %>%
  summarise(do_union = FALSE) %>%
  st_cast("LINESTRING")
  
edges <- edges %>%
  mutate(edgeID = c(1:n()))

nodes <- edges %>%
  st_coordinates() %>%
  as_tibble() %>%
  rename(edgeID = L1) %>%
  group_by(edgeID) %>%
  slice(c(1, n())) %>%
  ungroup() %>%
  mutate(start_end = rep(c('start', 'end'), times = n()/2)) %>%
  mutate(xy = paste(.$X, .$Y)) %>% 
  mutate(nodeID = group_indices(., factor(xy, levels = unique(xy)))) %>%
  select(-xy)

source_nodes <- nodes %>%
  filter(start_end == "start") %>%
  pull(nodeID)

target_nodes <- nodes %>%
  filter(start_end == "end") %>%
  pull(nodeID)
  
edges = edges %>%
  mutate(from = source_nodes, to = target_nodes)

nodes <- nodes %>%
  distinct(nodeID, .keep_all = TRUE) %>%
  st_as_sf(coords = c('X', 'Y'), crs = 27700) %>%
  select(nodeID, geometry)
  #st_set_crs(st_crs(edges))

network <- sfnetwork(nodes, edges, directed = TRUE) %>%
  activate(edges) %>%
  mutate(length = st_length(geometry))
  
network <- network %>%  
  activate(nodes) %>%
  mutate(degree = centrality_degree()) %>%
  mutate(betweenness = centrality_betweenness(weights = as.numeric(length) + 0.0001)) %>%
  mutate(eigen = centrality_eigen()) %>%
  activate(edges) %>%
  mutate(betweenness = centrality_edge_betweenness(weights = as.numeric(length) + 0.0001))

tm_shape(network %>% activate(edges) %>% as_tibble() %>% st_as_sf()) + 
  tm_lines() + 
  tm_shape(network %>% activate(nodes) %>% as_tibble() %>% st_as_sf()) +
  tm_dots(col = "betweenness", size = "betweenness", palette = "cividis")

```


Column {data-width=650}
-----------------------------------------------------------------------

### Betweenness centrality

```{r}

tm_shape(network %>% activate(edges) %>% as_tibble() %>% st_as_sf()) + 
  tm_lines(col = "betweenness") + 
  tm_shape(network %>% activate(nodes) %>% as_tibble() %>% st_as_sf()) +
  tm_dots(col = "eigen", size = "degree", palette = "cividis")


```
